import{r as i,a as o,e as a,F as n,c as e,o as r}from"./app.78facd3f.js";import{_ as t}from"./plugin-vue_export-helper.21dcd24c.js";const c={},d=e('<h1 id="concept" tabindex="-1"><a class="header-anchor" href="#concept" aria-hidden="true">#</a> Concept</h1><p>The concept behind PURISTA is quite simple and a message based approach.<br> There are message senders and receivers. Messages are exchanged via an eventbridge.</p><p>The logic resists in Service. They are the DDD part.<br> A service is a logical group of commands and subscriptions which are relating to a single domain.</p><p>Commands are active triggered by someone and the caller expects some kind of result. This is similar to a functions in any programming language. It means the caller knows about the existence of the called service &amp; command and he knows at least the input and output format and maybe something about possible error responses. How the called command function is implemented or how it is working is unknown and not related for the caller.</p><p>Subscriptions are a passive part like event listeners. A subscription is triggered as soon as a messages matches the subscription criteria. The producer of this message does not have knowledge about this subscription.</p><p>Commands and subscription can call other commands from same or other service by sending command messages. This means, there is a clean, structured and unified internal interface, which is also observable and traceable with error handling out of the box.</p><p>This allows real complex setups and scenarios.</p><p>Example:</p>',8),l=e("<ul><li>the browser calls the endpoint <code>/api/v1/user-sign-up</code></li><li>the webserver will send a command request <code>signUp</code> to service <code>User</code></li><li>the command <code>signUp</code> is responding to webserver with the id of this new created user</li><li>the webserver will respond to the browsers request</li><li>the service <code>User</code> has a subscription <code>verifyEmail</code> which is listening to all successfull calls to <code>signUp</code> command</li><li>the subscription <code>verifyEmail</code> in service <code>User</code> is creating a verification token which is stored in users domain, creates the email subject and body and is sending a command <code>sendEmail</code> to the service <code>Email</code></li><li>the <code>sendEmail</code> command in service <code>Email</code> connects to the mail provider and sends the email</li><li>in service <code>Audit</code> we have also some subscription <code>countEmails</code> which is listening to all invocation responses of command <code>sendMail</code> from service <code>Email</code> which is counting success and failure. ...and so on</li></ul><p>Each of this steps is only one single and simple function, which is easy to implement, to understand and to test. Each of this steps has input-output-validation in place. Each step has it&#39;s own error handling and responses are divided into success and error response. Each step is decoupled from the others.</p><p>In our example: If creating the new user is failing, none of the other steps is started and the browser receives a propper error response. If sending of verification email is failing, it does not effect the user creation and it is traced by the <code>Audit</code> service.</p><p>If you might want to extend this, to send two-factor-pin via sms, you simply need to add a new service <code>SMS</code> with a command <code>sendSms</code>. Add a subscription <code>send2FA</code> in service <code>User</code>, which is listening to successfull user creations like the <code>verifyEmail</code> subscription does.<br> Invoke <code>sendSms</code> in service <code>SMS</code> from subscription <code>send2FA</code> in service <code>User</code>.</p><p>We might need a new version of user sign up, because now, the input payload has a required field <code>phoneNumber</code> for our 2FA. But we do not want to break any existing and working thing.</p><p>We simply copy the whole service <code>User</code> to a new service <code>User2</code>.<br> For service <code>User2</code> we bump version to <code>2.0.0</code>.</p><p>All api endpoints for <code>User2</code> are now directly available as <code>api/v2/</code> and our new Service is also reachable by all other services.<br> Now we can safely make our changes in <code>User2</code> and mark <code>api/v1/</code> as deprecated.<br> As soon as we finished our changes, tested them and so on, we can completely switch to the new version and remove the old one.</p>",7);function p(h,m){const s=i("Mermaid");return r(),o(n,null,[d,a(s,{id:"mermaid-382ee168","data-code":"flowchart%20RL%0A%20%20%20%20browser%5BBrowser%5D%20--%3E%7C%2Fapi%2Fv1%2Fuser%2Fsign-up%7C%20httpService(HTTPS-Service)%0A%20%20%20%20httpService--%20user%20payload%20--%3EeventBridge(Eventbridge)%0A%20%20%20%20eventBridge--%20user%20payload%20--%3EsignUp%0A%20%20%20%20subgraph%20UserService%0A%20%20%20%20%20%20%20%20signUp%0A%20%20%20%20%20%20%20%20verifyEmail(verifyEmail)%0A%20%20%20%20end%0A%20%20%20%20signUp--%20user%20id%20--%3EeventBridge%0A%20%20%20%20eventBridge%20--%20user%20id%20--%3E%20httpService%0A%20%20%20%20httpService%20--%20user%20id%20--%3E%20browser%0A%20%20%20%20eventBridge%20-.-%3E%20verifyEmail%0A%20%20%20%20signUp%20--%3E%20database%0A%20%20%20%20database%20--%20user%20id%20--%3E%20signUp%0A%20%20%20%20verifyEmail%20--%20set%20token%20--%3Edatabase%0A%20%20%20%20verifyEmail%20--%3E%20eventBridge%0A%20%20%20%20eventBridge%20--%3E%20sendMail%0A%20%20%20%20subgraph%20EmailService%0A%20%20%20%20%20%20%20%20sendMail%0A%20%20%20%20end%0A%0A%20%20%20%20eventBridge%20-.-%3E%20countEmails%0A%20%20%20%20subgraph%20Audit%0A%20%20%20%20%20%20%20%20countEmails(countEmails)%0A%20%20%20%20end%0A%20%20%20%20countEmails%20--%3E%20database%0A%20%20%20%20database%5B(Database)%5D%0A"}),l],64)}var g=t(c,[["render",p],["__file","0_concept.html.vue"]]);export{g as default};
