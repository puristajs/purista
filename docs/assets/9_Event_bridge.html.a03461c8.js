import{_ as o}from"./plugin-vue_export-helper.21dcd24c.js";import{o as r,c as i,b as a,e as n,a as t,d as e,r as h}from"./app.5b57730e.js";const d={},l=t('<h1 id="event-bridge" tabindex="-1"><a class="header-anchor" href="#event-bridge" aria-hidden="true">#</a> Event bridge</h1><h2 id="general" tabindex="-1"><a class="header-anchor" href="#general" aria-hidden="true">#</a> General</h2><p>The concept of PURISTA is based on &quot;some&quot; message broker. The message broker is handling all the communication messages between single functions and subscriptions.</p><p>There are a lot of different message system out there. So the question is, which one to choose. So, what features should an ideal message broker provide.</p><h3 id="push-based" tabindex="-1"><a class="header-anchor" href="#push-based" aria-hidden="true">#</a> Push based</h3><p>The broker should actively deliver messages to the client instead of client pull. The reason is, that if you deploy in serverless function style, single functions are stateless, and the single instances are only existing at the time of execution. So, there is no instance at all, which can continuously pulling for new messages.</p><h3 id="queues" tabindex="-1"><a class="header-anchor" href="#queues" aria-hidden="true">#</a> Queues</h3><p>Most of the brokers have the concept of queues, but not all queue concepts are sufficient for our use case.</p><p>To be able to share the load across multiple instances, the queue mechanism must be able to send one single message to exactly one client instance. It should not send the same message to multiple client instances.</p><p>An other point to mentioned here:<br> We need in best case persistency per queue. Queues for command requests/responses should not hold the messages forever. If a command or its response is not handled within a given amount of time, the request has been timed out. So there is no need to deliver these messages after timeout.</p><p>But on the other hand, subscriptions should be able to handle messages later and the information should not get lost.</p><h3 id="rpc-request-reply" tabindex="-1"><a class="header-anchor" href="#rpc-request-reply" aria-hidden="true">#</a> RPC request/reply</h3><p>The broker must be able to provide some way, to build a request-replay mechanism. Otherwise, it is not possible to call a service function and receive a result.<br> In general, this pattern can be build with some kind of response queue. But, as our functions and subscriptions are maybe serverless/stateless, we will need the possibility to have response queues, which are short living and automatically created and removed.</p><h3 id="content-based-delivery" tabindex="-1"><a class="header-anchor" href="#content-based-delivery" aria-hidden="true">#</a> Content based delivery</h3><p>Many message brokers have the concept of topics or routing key delivery. This works well, if you have some fixed topics or routing keys. The service function part of PURISTA would work, because you could simply use a combination of message type, service name, service version and function/subscription name as a routing key.</p><p>But what about subscriptions? Subscriptions are kind of dynamic and unknown. You might want to subscribe to one single event name, or you might want to subscribe to all error responses from any service function.</p><p>Also, you do not want to have a 1:1 relation. You always have one message producer, but you might have n message consumers.</p><p>The broker must be able to deliver the same message to n different consumers, based on the message and the consumers.</p><h2 id="defaulteventbridge" tabindex="-1"><a class="header-anchor" href="#defaulteventbridge" aria-hidden="true">#</a> DefaultEventBridge</h2><p>The core package comes with <code>DefaultEventBridge</code> which will work on local without any further installation. This should work out of the box for single instances.<br> You can also use it for simple horizontal scaling. The messages and states are not shared or load balanced between instances.</p><p>This means a subscription is always running on the same instance. Also, any function invocation is done within the same instance.</p><p>Because of this, the <code>DefaultEventBridge</code> will only work in scenarios, where you deploy your services as monolith.</p><h2 id="amqp-event-bridge" tabindex="-1"><a class="header-anchor" href="#amqp-event-bridge" aria-hidden="true">#</a> AMQP event bridge</h2><p>The AMQP protocol and the corresponding brokers are perfectly for PURISTA.</p>',24),c=e("The package "),u=a("code",null,"@purista/amqpbridge",-1),p=e(" provides an event bridge for the AMQP protocol. This means you can use "),b={href:"https://www.rabbitmq.com",target:"_blank",rel:"noopener noreferrer"},m=e("RabbitMQ"),g=e(" as message broker. This is the recommended message broker. Also, "),f={href:"https://activemq.apache.org/",target:"_blank",rel:"noopener noreferrer"},v=e("Apache ActiveMQ"),y=e(" should work."),w=t(`<p>By using the AMQP event bridge, the system will scale and load balance any task across all instances.<br> It also allows you, to choose a more flexible way of deployment, as you are now able to split your monolith into small pieces.</p><p>You can:</p><ul><li>spin up multiple monolith instances</li><li>you can split your monolith by services and run multiple service instances (microservice style)</li><li>you can split even more down to single function and subscription level</li><li>you are able to connect other systems via the amqp broker</li></ul><p>The easiest way to start - simply start a RabbitMQ docker container:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">docker</span> run --rm -it --hostname my-rabbit -p <span class="token number">15672</span>:15672 -p <span class="token number">5672</span>:5672 rabbitmq:3-management
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="aws" tabindex="-1"><a class="header-anchor" href="#aws" aria-hidden="true">#</a> AWS</h2><h3 id="aws-eventbridge" tabindex="-1"><a class="header-anchor" href="#aws-eventbridge" aria-hidden="true">#</a> AWS EventBridge</h3><h3 id="aws-sns" tabindex="-1"><a class="header-anchor" href="#aws-sns" aria-hidden="true">#</a> AWS SNS</h3><h3 id="aws-mq" tabindex="-1"><a class="header-anchor" href="#aws-mq" aria-hidden="true">#</a> AWS MQ</h3><h2 id="azure" tabindex="-1"><a class="header-anchor" href="#azure" aria-hidden="true">#</a> Azure</h2><h3 id="azure-service-grid" tabindex="-1"><a class="header-anchor" href="#azure-service-grid" aria-hidden="true">#</a> Azure Service Grid</h3><h3 id="azure-event-hubs" tabindex="-1"><a class="header-anchor" href="#azure-event-hubs" aria-hidden="true">#</a> Azure Event Hubs</h3><h3 id="azure-service-bus" tabindex="-1"><a class="header-anchor" href="#azure-service-bus" aria-hidden="true">#</a> Azure Service Bus</h3><h2 id="google-cloud" tabindex="-1"><a class="header-anchor" href="#google-cloud" aria-hidden="true">#</a> Google Cloud</h2><h2 id="apache-kafka" tabindex="-1"><a class="header-anchor" href="#apache-kafka" aria-hidden="true">#</a> Apache Kafka</h2><h2 id="mqtt-brokers" tabindex="-1"><a class="header-anchor" href="#mqtt-brokers" aria-hidden="true">#</a> MQTT Brokers</h2><p>MQTT is one of the most mature and widely used messaging protocols. As mentioned in the beginning of this page, there are several things a broker should provide.</p><p>The MQTT protocol version 5 has some interesting additions, like shared subscriptions, session ttl, message ttl and response fields. This reduces the gap between available broker features and our needs.</p><p>But handling subscriptions is still not possible out of the box. Delivering one message to multiple consumers, based on the message and the consumers, can&#39;t be handled by the brokers right now.</p>`,19);function k(_,x){const s=h("ExternalLinkIcon");return r(),i("div",null,[l,a("p",null,[c,u,p,a("a",b,[m,n(s)]),g,a("a",f,[v,n(s)]),y]),w])}var A=o(d,[["render",k],["__file","9_Event_bridge.html.vue"]]);export{A as default};
