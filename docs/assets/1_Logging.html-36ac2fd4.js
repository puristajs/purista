import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as s,c as l,b as o,d as e,e as a,a as n}from"./app-2c9217f0.js";const c={},d=o("h2",{id:"logging",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#logging","aria-hidden":"true"},"#"),e(" Logging")],-1),p=o("br",null,null,-1),u={href:"https://getpino.io/",target:"_blank",rel:"noopener noreferrer"},h={href:"https://github.com/pinojs/pino-pretty",target:"_blank",rel:"noopener noreferrer"},g=n(`<p>But you can in theory use any logging library. There is only the need to build a simple wrapper.<br> This wrapper should be a class which extends <code>Logger</code> from <code>@purista/core</code>. See <code>DefaultLogger.ts</code> in core package.</p><p>The logger is expected to log:</p><ul><li>serviceName</li><li>serviceVersion</li><li>serviceTarget (available logged in context of a command or subscription)</li><li>principalId (if available)</li><li>traceId</li><li>spanId</li><li>parentSpanId</li><li>traceFlags</li></ul><p>When messages are logged - the message payload will be removed to prevent leaking of data.</p><p>To log errors with stacktrace correctly, you should log them as <code>err</code>.</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code>logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token punctuation">{</span> err <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&#39;my own error message&#39;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>You <strong>should not use</strong> <code>traceId</code>, <code>spanId</code>, <code>parentId</code>, <code>parentSpanId</code>, <code>traceFlags</code> or <code>principalId</code> as property of the logging object. This might overwrite automatically added log information.</p><p>Available log levels are <code>info</code>, <code>fatal</code>, <code>error</code>, <code>warn</code>, <code>debug</code> and <code>trace</code>.</p><p>Internally, PURISTA tries to cover these use cases with different log levels:</p><p><code>info</code> = general information like used port, service status and so on <code>fatal</code> = if a service is unable to start at all <code>error</code> = if some unexpected/unhandled error occurs like a command function is throwing <code>warning</code> = if for example a http request fails because of input validation <code>debug</code> = general framework flow information which should not be logged in production <code>trace</code> = detailed raw data mainly of third party plugins</p><p>In production, log level <code>warn</code> is recommended.</p><div class="hint-container info"><p class="hint-container-title">Info</p><p>Service instances will create a own logger</p></div><h2 id="error-tracking-within-the-program" tabindex="-1"><a class="header-anchor" href="#error-tracking-within-the-program" aria-hidden="true">#</a> Error tracking within the program</h2>`,13),m={href:"https://sentry.io/",target:"_blank",rel:"noopener noreferrer"},f=o("br",null,null,-1),b=n('<p>To allow a flexible and decoupled way, a service emits the following events:</p><ul><li><code>handled-subscription-error</code> emitted when a subscription throws a HandledError</li><li><code>handled-command-error</code> emitted when a command throws a HandledError</li><li><code>unhandled-subscription-error</code> emitted when a subscription throws an error other than a HandledError</li><li><code>unhandled-command-error</code> emitted when a command throws an error other than a HandledError</li></ul><p>This means, you can attach your logic like opening a issue in your ticket system, instead of deeply integrate it into your business logic.</p><h3 id="events-vs-subscription" tabindex="-1"><a class="header-anchor" href="#events-vs-subscription" aria-hidden="true">#</a> Events vs subscription</h3><p>There is also the option to have a subscription for error messages. This only works for functions, but not for subscriptions, as they do not emit a response message. Also, the error handling should be close to the root cause, it works even when there is an issue with event bus, and it might be faster when it comes to alerting.</p><p>But, subscriptions can be the preferred way, if you like to build some (business) analytics like &quot;hourly average of...&quot;.<br> Because this way, you also get some decoupled and isolated solution.</p>',6);function y(v,w){const r=i("ExternalLinkIcon");return s(),l("div",null,[d,o("p",null,[e("PURISTA provides logging as integral part."),p,e(" Per default, "),o("a",u,[e("pino"),a(r)]),e(" is used under the hood as logging library.")]),o("p",null,[e("This means, during development you are able to use "),o("a",h,[e("pino-pretty"),a(r)]),e(" for better human readable console log output.")]),g,o("p",null,[e("To allow a more flexible way of tracking, monitoring or alerting, you might want to use some external services like "),o("a",m,[e("sentry"),a(r)]),e(" or you like to programmatically react on errors and issues."),f,e(" For example, automatically open a issue in your ticket system.")]),b])}const x=t(c,[["render",y],["__file","1_Logging.html.vue"]]);export{x as default};
