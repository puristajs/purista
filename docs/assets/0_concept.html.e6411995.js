import{_ as r}from"./plugin-vue_export-helper.21dcd24c.js";import{r as o,o as d,c,e as t,b as a,w as h,a as s,d as e}from"./app.414c019c.js";const l={},u=s('<h1 id="concept" tabindex="-1"><a class="header-anchor" href="#concept" aria-hidden="true">#</a> Concept</h1><h2 id="main-idea" tabindex="-1"><a class="header-anchor" href="#main-idea" aria-hidden="true">#</a> Main idea</h2><p>The concept behind PURISTA is quite simple and a message based approach.<br> There are message senders and receivers. Messages are exchanged via an event bridge.</p><p>The logic resists in Service. They are the DDD part.<br> A service is a logical group of commands and subscriptions which are relating to a single domain.</p><p>Commands are active, triggered by someone, and the caller expects some kind of result. This is similar to functions in any programming language. It means the caller knows about the existence of the called service &amp; command, and he knows at least the input and output format and maybe something about possible error responses. How the called command function is implemented or how it is working is unknown and not related to the caller.</p><p>Subscriptions are a passive part, like event listeners. A subscription is triggered as soon as a message matches the subscription criteria. The producer of this message does not have knowledge about this subscription.</p><p>Commands and subscription can call other commands from same or other service by sending command messages. This means, there is a clean, structured and unified internal interface, which is also observable and traceable with error handling out of the box.</p><p>This allows real complex setups and scenarios.</p><h2 id="example" tabindex="-1"><a class="header-anchor" href="#example" aria-hidden="true">#</a> Example</h2><p>We will use a simple example for better understanding.</p>',10),p=s('<ul><li>the browser calls the endpoint <code>/api/v1/user-sign-up</code></li><li>the web server will send a command request <code>signUp</code> to service <code>User</code></li><li>the command <code>signUp</code> is responding to web server with the ID of this new created user</li><li>the web server will respond to the browsers request</li><li>the service <code>User</code> has a subscription <code>verifyEmail</code> which is listening to all successful calls to <code>signUp</code> command</li><li>the subscription <code>verifyEmail</code> in service <code>User</code> is creating a verification token which is stored in user&#39;s domain, creates the email subject and body and is sending a command <code>sendEmail</code> to the service <code>Email</code></li><li>the <code>sendEmail</code> command in service <code>Email</code> connects to the mail provider and sends the email</li><li>in service <code>Audit</code> we have also some subscription <code>countEmails</code> which is listening to all invocation responses of command <code>sendMail</code> from service <code>Email</code> which is counting success and failure. ...and so on</li></ul><p>Each of these steps is only one single and simple function, which is easy to implement, to understand and to test. Each of these steps has input-output-validation in place. Each step has its own error handling and responses are divided into success and error response. Each step is decoupled from the others.</p><p>In our example: If creating the new user is failing, none of the other steps is started and the browser receives a proper error response. If sending of verification email is failing, it does not affect the user creation, and it is traced by the <code>Audit</code> service.</p><p>If you might want to extend this, to send two-factor-pin via SMS, you simply need to add a new service <code>SMS</code> with a command <code>sendSms</code>. Add a subscription <code>send2FA</code> in service <code>User</code>, which is listening to successful user creations, like the <code>verifyEmail</code> subscription does.<br> Invoke <code>sendSms</code> in service <code>SMS</code> from subscription <code>send2FA</code> in service <code>User</code>.</p><p>We might need a new version of user sign up, because now, the input payload has a required field <code>phoneNumber</code> for our 2FA. But we do not want to break any existing and working thing.</p><p>We simply copy the whole service <code>User</code> to a new service <code>User2</code>.<br> For service <code>User2</code> we bump version to <code>2.0.0</code>.</p><p>All API endpoints for <code>User2</code> are now directly available as <code>api/v2/</code> and our new Service is also reachable by all other services.<br> Now we can safely make our changes in <code>User2</code> and mark <code>api/v1/</code> as deprecated.<br> As soon as we finished our changes, tested them and so on, we can completely switch to the new version and remove the old one.</p><h2 id="seriously-a-new-framework" tabindex="-1"><a class="header-anchor" href="#seriously-a-new-framework" aria-hidden="true">#</a> Seriously a new framework</h2><p>You might ask yourself, why the hell there is a need for some other framework.<br> Because there are more or less three kinds of frameworks out there.</p><h3 id="the-old-stars" tabindex="-1"><a class="header-anchor" href="#the-old-stars" aria-hidden="true">#</a> The old stars</h3><p>The most mature ones, are focused on creating some kind of webserver.<br> No matter if it is express.js, hapi, restify/fastify and all the other cool ones.<br> There is a huge ecosystem around these frameworks.<br> They are pretty cool and helpful creating webservers, but they don&#39;t help you to build the logic behind some endpoints.<br> PURISTA does not try to replace them. PURISTA will bring the missing part for building the logic behind the endpoints and you should be able to combine them.</p><p>In fact, it works pretty well, to combine these frameworks with PURISTA.<br> The provided package <code>@purista/httpserver</code> is using fastify under the hood.</p><h3 id="the-unicorns" tabindex="-1"><a class="header-anchor" href="#the-unicorns" aria-hidden="true">#</a> The unicorns</h3><p>The next kind of frameworks are the unicorns - the specialists.<br> They are focused on solving specific issues and requirements, and do not try to &quot;fit for all usecases&quot;.<br> Let&#39;s give a big \u{1F44F} to Feathers and Moleculer as cool examples for this category.<br> Pretty sure there are some other awesome unicorns out there. Just let us know!</p><p>Highly recommended to try them out, play around, do some cool stuff and maybe they perfectly fit for your next project.</p><h3 id="the-philosophers" tabindex="-1"><a class="header-anchor" href="#the-philosophers" aria-hidden="true">#</a> The philosophers</h3><p>The third category are the philosophers. They are focused on patterns, styles, conventions, abstractions, layers and wrappers.<br> You end up with framework specific decorators, dependency injections and other (uncool) stuff like that. Let&#39;s mention NestJs and Ts.ED at this point.<br> They are the complete opposite of PURISTA and the antipattern of PURISTA&#39;s main idea.</p><h3 id="purista" tabindex="-1"><a class="header-anchor" href="#purista" aria-hidden="true">#</a> PURISTA</h3><p>PURISTA tries to have no framework specific stuff as much as possible.<br> It does not try to treat developers to use certain patterns, conventions or styles.<br> It tries to separate, decouple things and to avoid having dependencies within your logic.</p><p>For example, with dependency injections, you have the need, that your dependency is instantiated within your current progess.<br> This is a first warning sign for questions like &quot;How to scale things up?&quot; and &quot;How to handle multiple instances&quot; and &quot;How to maintain&quot;.</p><p>You quickly end up with one dependency injection for database, one for websockets, one for logging, one for...<br> ...all they need to be available in your current process...<br> At the end you&#39;ve build one monolithic monster, which might become totally unpredictable and maintable.<br> It is the scenario you should avoid: simple changes on one end and it possibly fails on some other end.</p><p>PURISTA tries to avoid and solve this issue by using a unified event bus and to adapt some of the domain driven development patterns. This means you are able to break this dependency chain, and you are able to use ressources which are available somehow, somewhere.<br> This also increases stability, because if one part isn&#39;t working, the rest won&#39;t crash or stop working from technical perspective.<br> PURISTA adapts the idea of microservices and serverless functions from that point of view.</p><p>As an example:</p><p>You might have some service function which receives a http request.<br> You process the data, you persist the data and you send some message via websocket.</p><p>With dependency injections, you will need to have error handling within your function for processing the data, persisting the data and sending messages over websocket. And in case the persistency is unavailable or the websocket connection get&#39;s temporary lost - you do what?<br> You can start adding more abstractions, layers and stuff to workaround, but does this really fix the underlaying problem and is it worth to have such code bloat from testing and maintaining perspective?</p><p>With the approach of PURISTA, you get the a validated input, you process the data, you persist somehow, and you send a message via websocket somehow.<br> If, how and when does not matter for the input processing part.<br> Each of the steps has verified in-/output and basic error handling out of the box.</p><p>Depending on the event bus you choose:<br> You can build real robust and scalable system, because you can setup your system to be able to be fully asynchronous and recoverable.<br> If the persistance part isn&#39;t available right now, the information can be hold within the event bus until the persistance part is available.<br> You can build the system to send the message via websocket, no matter if the persistance part is done. Or you can decide to trigger the websocket part as soon as the persistance part is done. And again, you can decide what should happend, when the websocket connection is currently unavailable.</p><p>This is a huge benefit to control how to handle such cases, as you are now able to control if you like to loose business data.</p><p>You can scale out as you need, as there are maybe multiple instances running which are able to persist data or to send websocket messages.</p><h3 id="focus-on-business-logic" tabindex="-1"><a class="header-anchor" href="#focus-on-business-logic" aria-hidden="true">#</a> Focus on business logic</h3><p>These 4 words are describing the intention and motivation behind PURISTA.</p><p>Focus on business logic, solve the clients issue, provide the features and just deliver!</p><p>Just go through your own code and check what is your daily business?</p><p>You get some kind of input, you validate it, you compute something, request some data, maybe persist some data and you return some result or you trigger some other function.<br> You will have some error handling and some logging.</p><p>How much setup, configuration, abstraction, layers do you really need and much code do you produce for even simple stuff?</p><h3 id="decuple-from-infrastructure-and-architecture" tabindex="-1"><a class="header-anchor" href="#decuple-from-infrastructure-and-architecture" aria-hidden="true">#</a> Decuple from infrastructure and architecture</h3><p>One of the key features of PURISTA is the separation of business logic from architectural and/or infrastructure decisions.<br> It&#39;s done by the concept of having services with functions and subscriptions which are communicating over some event bridge.</p><p>How they are orchestrated, deployed and where they are running does not matter.</p><p>You can decide if you want to deploy your logic as single monolith or in some microservice style or as serverless functions.<br> There is no need to decide if you like to use your own server or to some cloud provider.</p><h3 id="k-i-s-s" tabindex="-1"><a class="header-anchor" href="#k-i-s-s" aria-hidden="true">#</a> K.I.S.S.</h3><p>Keep things as simple as possible and do not overcomplicate everything.<br> Do not try to do some fancy stuff only <em>&quot;Because I can&quot;</em>.<br> Do not try to write typescript in the style of other languages like JAVA. If you want to write Java code - it&#39;s fine - but then please use Java.</p><p>Do not loose yourself in patterns and abstractions and stuff like this.<br> Object/class style fits best for your current needs? Use it! Functional programming style makes more sense at some other point? Use it! A abstraction at a specific code snipped makes sense? Do it! Some layer might not be necessary or overkill? Remove it!</p><p>You got all the knowledge! Use it! Mix it up! Your code - you rules!<br> Do not write hundreds of code lines, only because of &quot;that is the correct way to follow the XXX pattern&quot; or &quot;it is the way you have to use the framework&quot;.</p><p>Don&#39;t write 100 lines if you can do it in 5 (only if you don&#39;t get payed per line of course).</p><h3 id="low-learning-curve" tabindex="-1"><a class="header-anchor" href="#low-learning-curve" aria-hidden="true">#</a> Low learning curve</h3><p>Using PURISTA should be easy and joyfull.<br> Even with beginner level knowledge it should be possible to build cool, stable and production ready stuff.<br> There are lot&#39;s of &quot;If you want or if you need, you can...&quot;.<br> There are some &quot;It is recommended, to ...&quot;. But there are only a few &quot;You must...&quot;.</p><p>Also there is a wild mix of adaptions from known things like microservices, domain driven development, functional programming, event patterns, messaging systems. So, anybody with some fundamental experiences, will get the &quot;ah, I know this, it&#39;s like...&quot; effect.<br> No rocket science at all - but hopefully it rocks your next project \u{1F680}.</p><h3 id="predictable-behavior" tabindex="-1"><a class="header-anchor" href="#predictable-behavior" aria-hidden="true">#</a> Predictable behavior</h3><p>Predictable behavior is one of the fundamentals of PURISTA.<br> As an example let&#39;s mention the integrated input/output validation here.<br> In normal scenarios, every function input and result output is validated against a schema at runtime and has propper types out of the box during development.<br> This means you already know there will be no technical incorrect input at any point, no unwanted output which might leak some data and you exactly know the error handling on invalid data.<br> Also, any thrown error will be automatically catched, logged and transformed into a defined error(-response) shape.</p><p>Especially javascript/typescript is often blamed for it&#39;s error handling, but this also some opportunity.<br> It is js/typescript - let it throw! PURISTA will handle the worst case for you!<br> You don&#39;t need to implement error handling for any possible error which might occur.<br> Handle only the errors you need to handle at business level and improve your code, architecture and infrastructure over time to avoid technical errors! There is simply no need to have always some wrapped result, where you need to check, if it is a success or failure. And if it is a failure, what kind of failure and how to handle it and how to bubble up the error.</p><p>The usage of some unified exchange bus allows to highly configure what &quot;happens when...&quot;. It allows to build setups which are able to replay things, recover states, execute &quot;when available&quot; and so on.</p><h3 id="maintenance" tabindex="-1"><a class="header-anchor" href="#maintenance" aria-hidden="true">#</a> Maintenance</h3><p>Maintenance is very important to any project and highly impact costs and speed of future enhancements.</p><p>PURISTA tries to lower the effort and costs for maintaining by splitting high complex scenarios into small, simple pieces in combination with defined interfaces and the ability to version services.</p><p>This offers opportunities, like having different versions in parallel, instead of dangerous &quot;close eyes, press switch button and fingers crossed&quot;.</p><p>But more important:</p><p>Smaller pieces are easier to understand, easier to change, easier to test and you avoid the cascading &quot;if I touch this, I need to touch everything&quot;</p><h3 id="security" tabindex="-1"><a class="header-anchor" href="#security" aria-hidden="true">#</a> Security</h3><p>To build secure and stable software is essential for success.</p><p>Using PURISTA does not mean you end up with a 100% bullet proof solution without any effort. But it reduces or prevents a lot of possible issues by design.<br> Having a solid input/output validation on any single step, means an increase of overhead and also longer execution time. But it is worth to have it in place.<br> You prevent the system by design to allow technical invalid input (implausible), you verify the technical correctness (plausible) on each step and you prevent your system to leak data accidentally.<br> It also simplifies any audit, as you can go through each step of your system and you can proof &quot;I verify that... and on error it will... it will not allow to...&quot;.</p><p>So, PURISTA does not even try to avoid security issues like low encryptions, multi-vector-high profile hacker attacks or similar. But it builds a solid basement for your software. Based on validation, unified interfaces, error handling, predictable behavior and strict separation.<br> And a stable, solid and robust software, which only exposes needed information, means higher barrier for attackers and lower the risks for bugs.</p><h3 id="traceability" tabindex="-1"><a class="header-anchor" href="#traceability" aria-hidden="true">#</a> Traceability</h3><p>Traceability comes in place at least when something does not work as expected.</p><p>One kind of issues are the one which are the more technical ones. Some function is throwing some error. In other software designs, you often end up with some code line number, and you start digging into the code, follow all the logic through a lot of files. You jump from one abstraction to the next one. You check wrapper by wrapper, interfaces and all that stuff.</p><p>The other kind of issues are even more hard to track. If the stuff is working from technical point of view, but not from business view. In this case you need to walk through the code logic, and check if the business logic is matching the implementation logic. And depending on your abstractions, layers and wrappers you will quickly blow up your head.</p><p>The concept of PURISTA will help you in both cases. You simply follow the message flow. Check the input/output of the functions and you will find the root cause quickly.<br> You are able to follow single requests, because each one has a unique trace id all the way down. You can attach external providers and software solutions to track errors on each of your functions. You can track metrics on each of your functions.</p><h3 id="scaling" tabindex="-1"><a class="header-anchor" href="#scaling" aria-hidden="true">#</a> Scaling</h3><p>PURISTA adapts the ideas from microservices and serverless functions to separate the logic into small pieces and to use some way of unified communication. This means you can scale out things as you need.</p><p>The main difference is, that you do not need to decide at very first step, how you like to deploy or how you like to scale at the end.<br> You can simply start local and scale when you need. You are not nailed down to start with infrastructure or architectural questions and setups.</p><p>Start small and efficient like you would do with the beginners &quot;hello world&quot; example and move to the solution which fits your needs.</p><p>You are not limited to scale &quot;the whole blob&quot;. You are able to scale parts of your software differently.</p><p>As an example, you might have some function which takes longer for processing data. This means this function can&#39;t handle the same amount of requests, than the rest of your system. You are able to scale this specific part by adding more instances, without the need to have more instance for all of your functions.</p><h3 id="testing" tabindex="-1"><a class="header-anchor" href="#testing" aria-hidden="true">#</a> Testing</h3>',73),m=e("The core concept of PURISTA is helping you, when it comes to testing."),f=a("br",null,null,-1),b=e(" Check out the handbook chapter "),y=e("Testing");function g(w,v){const i=o("Mermaid"),n=o("RouterLink");return d(),c("div",null,[u,t(i,{id:"mermaid-382ee183",code:"flowchart%20RL%0A%20%20%20%20browser%5BBrowser%5D%20--%3E%7C%2Fapi%2Fv1%2Fuser%2Fsign-up%7C%20httpService(HTTPS-Service)%0A%20%20%20%20httpService--%20user%20payload%20--%3EeventBridge(Eventbridge)%0A%20%20%20%20eventBridge--%20user%20payload%20--%3EsignUp%0A%20%20%20%20subgraph%20UserService%0A%20%20%20%20%20%20%20%20signUp%0A%20%20%20%20%20%20%20%20verifyEmail(verifyEmail)%0A%20%20%20%20end%0A%20%20%20%20signUp--%20user%20id%20--%3EeventBridge%0A%20%20%20%20eventBridge%20--%20user%20id%20--%3E%20httpService%0A%20%20%20%20httpService%20--%20user%20id%20--%3E%20browser%0A%20%20%20%20eventBridge%20-.-%3E%20verifyEmail%0A%20%20%20%20signUp%20--%3E%20database%0A%20%20%20%20database%20--%20user%20id%20--%3E%20signUp%0A%20%20%20%20verifyEmail%20--%20set%20token%20--%3Edatabase%0A%20%20%20%20verifyEmail%20--%3E%20eventBridge%0A%20%20%20%20eventBridge%20--%3E%20sendMail%0A%20%20%20%20subgraph%20EmailService%0A%20%20%20%20%20%20%20%20sendMail%0A%20%20%20%20end%0A%0A%20%20%20%20eventBridge%20-.-%3E%20countEmails%0A%20%20%20%20subgraph%20Audit%0A%20%20%20%20%20%20%20%20countEmails(countEmails)%0A%20%20%20%20end%0A%20%20%20%20countEmails%20--%3E%20database%0A%20%20%20%20database%5B(Database)%5D%0A"}),p,a("p",null,[m,f,b,t(n,{to:"/handbook/6_testing.html"},{default:h(()=>[y]),_:1})])])}var T=r(l,[["render",g],["__file","0_concept.html.vue"]]);export{T as default};
