import{_ as t,c as i,o,ag as a}from"./chunks/framework.U_AETC1W.js";const u=JSON.parse('{"title":"Connect to PURISTA","description":"How to communicate and connect from external to a PURISTA application with client builder","frontmatter":{"title":"Connect to PURISTA","description":"How to communicate and connect from external to a PURISTA application with client builder","order":210000},"headers":[],"relativePath":"handbook/2_building_business-logic/connect_to_a_purista_application/index.md","filePath":"handbook/2_building_business-logic/connect_to_a_purista_application/index.md","lastUpdated":1739889299000}'),n={name:"handbook/2_building_business-logic/connect_to_a_purista_application/index.md"};function r(l,e,c,s,d,_){return o(),i("div",null,e[0]||(e[0]=[a('<h1 id="connect-the-outside-world-to-purista" tabindex="-1">Connect the Outside World to PURISTA <a class="header-anchor" href="#connect-the-outside-world-to-purista" aria-label="Permalink to &quot;Connect the Outside World to PURISTA&quot;">â€‹</a></h1><p>In real-world scenarios, you often need to allow external access to your application. You may want to provide a client package that is publicly available without exposing your entire internal codebase.</p><p>Since PURISTA uses the concept of builders, information about your structure, endpoints, and other details is already accessible for automation. This makes building a client a simple two-step process:</p><ol><li>Extract the necessary information from your code (<a href="./export_service_definitions.html">Export service definitions</a>)</li><li>Use the extracted information to generate clients: <ul><li><a href="./create_a_rest_api_client.html">REST API client</a></li><li><a href="./create_an_eventbridge_client.html">EventBridge</a> client</li><li><a href="./embedded_client.html">Embedded Client</a></li></ul></li></ol>',4)]))}const h=t(n,[["render",r]]);export{u as __pageData,h as default};
