import{_ as c}from"./plugin-vue_export-helper.21dcd24c.js";import{o as l,c as d,e as n,b as s,w as p,a,d as e,r as o}from"./app.869ed4d9.js";const u={},h=a('<h2 id="main-idea" tabindex="-1"><a class="header-anchor" href="#main-idea" aria-hidden="true">#</a> Main idea</h2><p>The concept behind PURISTA is quite simple and a message based approach.<br> There are message senders and receivers. Messages are exchanged via an event bridge.</p><p>The logic resists in Service. They are the DDD part.<br> A service is a logical group of commands and subscriptions which are relating to a single domain.</p><p>Commands are active, triggered by someone, and the caller expects some kind of result. This is similar to functions in any programming language. It means the caller knows about the existence of the called service &amp; command, and he knows at least the input and output format and maybe something about possible error responses. How the called command function is implemented or how it is working is unknown and not related to the caller.</p><p>Subscriptions are a passive part, like event listeners. A subscription is triggered as soon as a message matches the subscription criteria. The producer of this message does not have knowledge about this subscription.</p><p>Commands and subscription can call other commands from same or other service by sending command messages. This means, there is a clean, structured and unified internal interface, which is also observable and traceable with error handling out of the box.</p><p>This allows real complex setups and scenarios.</p><h2 id="example" tabindex="-1"><a class="header-anchor" href="#example" aria-hidden="true">#</a> Example</h2><p>We will use a simple example for better understanding.</p>',9),m=a('<ul><li>the browser calls the endpoint <code>/api/v1/user-sign-up</code></li><li>the web server will send a command request <code>signUp</code> to service <code>User</code></li><li>the command <code>signUp</code> is responding to web server with the ID of this new created user</li><li>the web server will respond to the browsers request</li><li>the service <code>User</code> has a subscription <code>verifyEmail</code> which is listening to all successful calls to <code>signUp</code> command</li><li>the subscription <code>verifyEmail</code> in service <code>User</code> is creating a verification token which is stored in user&#39;s domain, creates the email subject and body and is sending a command <code>sendEmail</code> to the service <code>Email</code></li><li>the <code>sendEmail</code> command in service <code>Email</code> connects to the mail provider and sends the email</li><li>in service <code>Audit</code> we have also some subscription <code>countEmails</code> which is listening to all invocation responses of command <code>sendMail</code> from service <code>Email</code> which is counting success and failure. ...and so on</li></ul><p>Each of these steps is only one single and simple function, which is easy to implement, to understand and to test. Each of these steps has input-output-validation in place. Each step has its own error handling and responses are divided into success and error response. Each step is decoupled from the others.</p><p>In our example: If the creation of the new user is failing, none of the other steps is started and the browser receives a proper error response. If sending of verification email is failing, it does not affect the user creation, and it is traced by the <code>Audit</code> service.</p><p>If you might want to extend this, to send two-factor-pin via SMS, you simply need to add a new service <code>SMS</code> with a command <code>sendSms</code>. Add a subscription <code>send2FA</code> in service <code>User</code>, which is listening to successful user creations, like the <code>verifyEmail</code> subscription.<br> Invoke <code>sendSms</code> in service <code>SMS</code> from subscription <code>send2FA</code> in service <code>User</code>.</p><p>We might need a new version of user sign up, because now, the input payload has a required field <code>phoneNumber</code> for our 2FA. But we do not want to break any existing and working thing.</p><p>We simply copy the whole service <code>User</code> to a new service <code>User2</code>.<br> For service <code>User2</code> we bump version to <code>2</code>.</p><p>All API endpoints for <code>User2</code> are now directly available as <code>api/v2/</code> and our new Service is also reachable by all other services.<br> Now we can safely make our changes in <code>User2</code> and mark <code>api/v1/</code> as deprecated.<br> As soon as we finished our changes, we can completely switch to the new version and remove the old one.</p><h2 id="seriously-a-new-framework" tabindex="-1"><a class="header-anchor" href="#seriously-a-new-framework" aria-hidden="true">#</a> Seriously, a new framework</h2><p>You might ask yourself why the hell there is a need for some other framework.<br> Because there are more or less three kinds of frameworks out there.</p><h3 id="the-old-stars" tabindex="-1"><a class="header-anchor" href="#the-old-stars" aria-hidden="true">#</a> The old stars</h3>',10),b=e("The most mature ones, are focused on creating some kind of web server."),f=s("br",null,null,-1),y=e(" No matter if it is "),g={href:"https://expressjs.com",target:"_blank",rel:"noopener noreferrer"},w=e("express.js"),v=e(", "),k={href:"https://hapi.dev",target:"_blank",rel:"noopener noreferrer"},_=e("hapi"),A=e(", [restify]("),x={href:"http://restify.com/%5Bfastify%5D(https://www.fastify.io)",target:"_blank",rel:"noopener noreferrer"},T=e("http://restify.com/[fastify](https://www.fastify.io)"),q=e(" and all the other cool ones."),I=s("br",null,null,-1),S=e(" There is a huge ecosystem around these frameworks."),U=s("br",null,null,-1),E=e(" They are pretty cool and helpful creating web servers, but they don't help you to build the logic behind endpoints."),P=s("br",null,null,-1),Y=e(" PURISTA does not try to replace them. PURISTA will bring the missing part for building the logic behind the endpoints, and you should be able to combine them."),R=s("p",null,[e("In fact, it works pretty well, to combine these frameworks with PURISTA."),s("br"),e(" The provided package "),s("code",null,"@purista/httpserver"),e(" is using fastify under the hood.")],-1),B=s("h3",{id:"the-unicorns",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#the-unicorns","aria-hidden":"true"},"#"),e(" The unicorns")],-1),D=e("The next kind of frameworks are the unicorns - the specialists."),j=s("br",null,null,-1),M=e(' They are focused on solving specific issues and requirements, and do not try to "fit for all use cases".'),F=s("br",null,null,-1),C=e(" Let's give a big \u{1F44F} to "),H={href:"https://feathersjs.com",target:"_blank",rel:"noopener noreferrer"},N=e("Feathers"),L=e(" and "),O={href:"https://moleculer.services",target:"_blank",rel:"noopener noreferrer"},V=e("Moleculer"),W=e(" as cool examples for this category."),J=s("br",null,null,-1),X=e(" Pretty sure there are some other awesome unicorns out there. Just let us know!"),K=a(`<p>Highly recommended trying them out, play around, do some cool stuff, and maybe they perfectly fit for your next project.</p><h3 id="the-philosophers" tabindex="-1"><a class="header-anchor" href="#the-philosophers" aria-hidden="true">#</a> The philosophers</h3><p>The third category are the philosophers. They are focused on patterns, styles, conventions, abstractions, layers and wrappers.<br> You end up with framework specific decorators, dependency injections and other (uncool) stuff like that. Let&#39;s mention NestJs and Ts.ED at this point.<br> They are the complete opposite of PURISTA and the antipattern of PURISTA&#39;s main idea.</p><h3 id="purista" tabindex="-1"><a class="header-anchor" href="#purista" aria-hidden="true">#</a> PURISTA</h3><p>PURISTA tries to have no framework specific stuff as much as possible.<br> It does not try to treat developers to use certain patterns, conventions or styles.<br> It tries to separate, decouple things and to avoid having dependencies within your logic.</p><p>For example, with dependency injections, you have the need, that your dependency is instantiated within your current process.<br> This is a first warning sign for questions like &quot;How to scale things up?&quot; and &quot;How to handle multiple instances&quot; and &quot;How to maintain&quot;.</p><p>You quickly end up with one dependency injection for database, one for websockets, one for logging, one for...<br> ...all they need to be available in your current process...<br> At the end, you&#39;ve built one monolithic monster, which might become totally unpredictable and maintainable.<br> It is the scenario you should avoid: simple changes on one end, and it possibly fails on some other end.</p><p>PURISTA tries to avoid and solve this issue by using a unified event bridge and to adapt some domain driven development patterns. This means you are able to break this dependency chain, and you are able to use resources which are available somehow, somewhere (blackbox).<br> This also increases stability, because if one part isn&#39;t working, the rest won&#39;t crash or stop working from a technical perspective.<br> PURISTA adapts the idea of microservices and serverless functions from that point of view.</p><p>As an example:</p><p>You might have some service function which receives a http request.<br> You process the data, you persist the data, and you send some message via websocket.</p><p>With dependency injections, you will need to have error handling within your function for processing the data, persisting the data and sending messages over websocket. And in case the persistency is unavailable or the websocket connection gets temporary lost - you do what?<br> You can start adding more abstractions, layers and stuff to workaround, but does this really fix the underlaying problem and is it worth to have such code bloat from testing and maintaining perspective?</p><p>With the approach of PURISTA, you get a validated input, you process the data, you persist somehow, and you send a message via websocket somehow.<br> Each of the steps has verified in-/output and basic error handling out of the box.</p><p>Depending on the event bridge you choose:<br> You can build a real robust and scalable system, because you can set up your system to be able to be fully asynchronous and recoverable.<br> If the persistence part isn&#39;t available right now, the information can be hold within the event bridge until the persistence part is available.<br> You can build the system to send the message via websocket, no matter if the persistence part is done. Or you can decide to trigger the websocket part as soon as the persistence part is done. And again, you can decide what should happen, when the websocket connection is currently unavailable.</p><p>This is a huge benefit to control how to handle such cases, as you are now able to control if you like to lose business data or not.</p><p>You can scale out as you need, as there are maybe multiple instances running which are able to persist data or to send websocket messages.</p><h3 id="focus-on-business-logic" tabindex="-1"><a class="header-anchor" href="#focus-on-business-logic" aria-hidden="true">#</a> Focus on business logic</h3><p>These 4 words are describing the intention and motivation behind PURISTA.</p><p>Focus on business logic, solve the client&#39;s issue, provide the features and just deliver!<br> It might need to change the mindset a bit. The question is not how to implement some feature. The question is what exactly does the user/consumer need and why.</p><p>Just go through your own code and check what is your daily business?</p><p>You get some kind of input, you validate it, you compute something, request some data, maybe persist some data, and you return some result or you trigger some other function.<br> You will have some error handling and some logging.</p><p>How much setup, configuration, abstraction, layers do you really need, and how much code do you produce for even simple stuff?</p><h3 id="separation-of-concerns" tabindex="-1"><a class="header-anchor" href="#separation-of-concerns" aria-hidden="true">#</a> Separation of concerns</h3><p>Depending on your experiences, this might be hard or easy going. Separation of concerns is more a kind of mindset, than a fixed pattern or style.</p><p>As an example:</p><p>You got a task &quot;Implement user onboarding&quot;, and there is something like &quot;allow only valid emails, store the user in database and send a welcome mail&quot;.<br> From a feature or business perspective, this is one single step &quot;user onboarding&quot;.<br> Many developers will automatically get a POST http endpoint in mind - something like:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">async</span> <span class="token punctuation">(</span>request<span class="token punctuation">,</span>response<span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>request<span class="token punctuation">.</span>body<span class="token punctuation">.</span>email<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>emailRegex<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> response<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">,</span><span class="token string">&#39;Invalid email&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">const</span> db <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getDbClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">let</span> user<span class="token operator">:</span>User<span class="token operator">|</span><span class="token keyword">undefined</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    user <span class="token operator">=</span> <span class="token keyword">await</span> db<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">&#39;insert into user values (....)&#39;</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span>body<span class="token punctuation">)</span>
    
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>error <span class="token keyword">instanceof</span> <span class="token class-name">ConstraintViolation</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> response<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">,</span><span class="token string">&#39;User already exists&#39;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//...further error handling</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> provider <span class="token operator">=</span> <span class="token function">getEmailProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">await</span> provider<span class="token punctuation">.</span><span class="token function">sendEmail</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>email<span class="token punctuation">,</span><span class="token string">&#39;Welcome&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  response<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token punctuation">{</span> id<span class="token operator">:</span> user<span class="token punctuation">.</span>id <span class="token punctuation">}</span><span class="token punctuation">)</span> 

<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Many developers would now instantly start with abstractions, as they want to improve readability, testing and so on.</p><p>So, you would probably see some <code>isUserEmailValid</code> abstraction function (100% for sure \u{1F602}), some wrappers around the database stuff, and some abstractions around sending the email. This might solve the developers issues, and produces a lot of nice bloat code.</p><p><strong>BUT it does not solve the business issue</strong>!</p><p>In fact, the issues and complexity are only hidden behind more code. At the end, you can write abstractions as much as you want, but at some point you need to do the &quot;real&quot; logic.<br> Don&#39;t get me wrong! Simply keep the balance. Abstractions and wrappers are ok and valid. But they are also a warning signal. Ask yourself always, why do you need it at some point. Can you avoid it with better design choices? Does it improve things from a business perspective?</p><p>In this example, one of the issues is: &quot;how to retry email send, if the users is persisted&quot;.<br> Try to solve issues by design! Not by more error handling or additional code logic.<br> Also, when the user onboarding becomes more complex (like creation of resources for new user), this function will become very quickly the little &quot;nobody wants to touch me&quot; monster.</p><p>With separation of concerns in mind, this will turn into 3 main parts.</p><ol><li>Input validation is one single step, and it does not matter what happens with the validated input afterwards.</li><li>Storing something in a database, and maybe handling database connection or issues, is the next part. It does not matter what happens &quot;around&quot; this persistence part. Simply take something and put it into database. That&#39;s it.</li><li>Sending an email is our third step. In this step, only the email is sent. It does not matter when, how the user is created or persisted. And you can retry the email part as you like.</li></ol><p>So, our complex &quot;onboarding&quot; is implemented, but the parts are simple and only a few lines of code. These are easy to understand, maintain and testable. You can also extend the onboarding flow by adding more parts (subscriptions, emitting events, invoking other functions). Or you can change your email provider or even database, without touching the other parts/tests.</p><p>PURISTA helps to implement and manage these small parts. Also, some parts are more or less available out of the box with low or no code implementation.</p><p>In our example, the database persistence will become a simple service function with a zod input schema definition. This provides a lot of input validation and error handling out of the box. Our send email part, will become a subscription. The subscription is decoupled from the http request.</p><h3 id="decuple-from-infrastructure-and-architecture" tabindex="-1"><a class="header-anchor" href="#decuple-from-infrastructure-and-architecture" aria-hidden="true">#</a> Decuple from infrastructure and architecture</h3><p>One of the key features of PURISTA is the separation of business logic from architectural and/or infrastructure decisions.<br> It&#39;s done by the concept of having services with functions and subscriptions which are communicating over some event bridge.</p><p>How they are orchestrated, deployed and where they are running does not matter.</p><p>You can decide, if you want to deploy your logic as a single monolith or in some microservice style or as serverless functions, or if you like a mix of multiple styles.<br> There is no need to decide if you like to use your own server or some cloud provider.</p><p>It also allows integrating other services and providers, without touching the core of your application. Simply add them to the event bus.<br> This is also a great option for larger projects, with multiple teams. Each team can work independently.</p><h3 id="k-i-s-s" tabindex="-1"><a class="header-anchor" href="#k-i-s-s" aria-hidden="true">#</a> K.I.S.S.</h3><p>Keep things as simple as possible and do not overcomplicate everything.<br> Do not try to do some fancy stuff only <em>&quot;Because I can&quot;</em>.<br> Do not try to write typescript in the style of other languages like JAVA. If you want to write Java code - it&#39;s fine - but then please use Java.</p><p>Do not lose yourself in patterns and abstractions and stuff like this.<br> Object/class style fits best for your current needs? Use it! Functional programming style makes more sense at some other point? Use it! An abstraction at a specific code snipped makes sense? Do it! Some layer might not be necessary or overkill? Remove it!</p><p>You got all the knowledge! Use it! Mix it up! Your code - your rules!<br> Do not write hundreds of code lines, only because of &quot;that is the correct way to follow the XXX pattern&quot; or &quot;it is the way you have to use the framework&quot;.</p><p>Don&#39;t write 100 lines if you can do it in 5 (only if you don&#39;t get payed per line, of course).</p><h3 id="low-learning-curve" tabindex="-1"><a class="header-anchor" href="#low-learning-curve" aria-hidden="true">#</a> Low learning curve</h3><p>Using PURISTA should be easy and joyfull.<br> Even with beginner level knowledge it should be possible to build cool, stable and production ready stuff.<br> There are lots of &quot;If you want or if you need, you can...&quot;.<br> There are some &quot;It is recommended, to ...&quot;. But there are only a few &quot;You must...&quot;.</p><p>Also, there is a wild mix of adaptions from known things like microservices, domain driven development, functional programming, event patterns, messaging systems. So, anybody with some fundamental experiences, will get the &quot;ah, I know this, it&#39;s like...&quot; effect.<br> No rocket science at all - but hopefully it rocks your next project \u{1F680}.</p><h3 id="predictable-behaviour" tabindex="-1"><a class="header-anchor" href="#predictable-behaviour" aria-hidden="true">#</a> Predictable behaviour</h3><p>Predictable behaviour is one of the fundamentals of PURISTA.<br> As an example, let&#39;s mention the integrated input/output validation here.<br> In normal scenarios, every function input and result output is validated against a schema at runtime and has proper types out of the box during development.<br> This means you already know there will be no technical incorrect input at any point, no unwanted output which might leak some data, and you exactly know the error handling on invalid data.<br> Also, any thrown error will be automatically caught, logged and transformed into a defined error(-response) shape.</p><p>Especially javascript/typescript is often blamed for its error handling, but this also some opportunity.<br> It is js/typescript - let it throw! PURISTA will handle the worst case for you!<br> You don&#39;t need to implement error handling for any possible error which might occur.<br> Handle only the errors you need to handle at business level and improve your code, architecture and infrastructure over time to avoid technical errors!<br> There is simply no need, to have always some wrapped result, where you need to check, if it is a success or failure. And if it is a failure, what kind of failure and how to handle it and how to bubble up the error.</p><p>The usage of some unified exchange bus allows to highly configure what &quot;happens when...&quot;. It allows building setups which are able to replay things, recover states, execute &quot;when available&quot; and so on.</p><h3 id="maintenance" tabindex="-1"><a class="header-anchor" href="#maintenance" aria-hidden="true">#</a> Maintenance</h3><p>Maintenance is very important to any project and highly impact costs and speed of future enhancements.</p><p>PURISTA tries to lower the effort and costs for maintaining by splitting high complex scenarios into small, simple pieces in combination with defined interfaces and the ability to version services.</p><p>This offers opportunities, like having different versions in parallel, instead of dangerous &quot;close eyes, press switch button and fingers crossed&quot;.</p><p>But more important:</p><p>Smaller pieces are easier to understand, easier to change, easier to test, and you avoid the cascading &quot;if I touch this, I need to touch everything&quot;</p><h3 id="security" tabindex="-1"><a class="header-anchor" href="#security" aria-hidden="true">#</a> Security</h3><p>To build secure and stable software is essential for success.</p><p>Using PURISTA does not mean you end up with a 100% bulletproof solution without any effort. But it reduces or prevents a lot of possible issues by design.<br> Having a solid input/output validation on any single step, means an increase of overhead and also longer execution time. But it is worth to have it in place.<br> You prevent the system by design to allow technical invalid input (implausible), you verify the technical correctness (plausible) on each step, and you prevent your system to leak data accidentally.<br> It also simplifies any audit, as you can go through each step of your system, and you can prove &quot;I verify that... and on error it will... it will not allow to...&quot;.</p><p>So, PURISTA does not even try to avoid security issues like low encryptions, multi-vector-high profile hacker attacks or similar. But it builds a solid basement for your software. Based on validation, unified interfaces, error handling, predictable behaviour and strict separation.<br> And a stable, solid and robust software, which only exposes needed information, means higher barrier for attackers and lower the risks for bugs.</p><h3 id="traceability" tabindex="-1"><a class="header-anchor" href="#traceability" aria-hidden="true">#</a> Traceability</h3><p>Traceability comes in place at least when something does not work as expected.</p><p>One kind of issues are the one which are the more technical ones. Some function is throwing some error. In other software designs, you often end up with some code line number, and you start digging into the code, follow all the logic through a lot of files. You jump from one abstraction to the next one. You check wrapper by wrapper, interfaces and all that stuff.</p><p>The other kind of issues are even harder to track. If the stuff is working from technical point of view, but not from business view. In this case, you need to walk through the code logic, and check if the business logic is matching the implementation logic. And depending on your abstractions, layers and wrappers you will quickly blow up your head.</p><p>The concept of PURISTA will help you in both cases. You simply follow the message flow. Check the input/output of the functions, and you will find the root cause quickly.<br> You are able to follow single requests, because each one has a unique trace id all the way down. You can attach external providers and software solutions to track errors on each of your functions. You can track metrics on each of your functions.</p><h3 id="scaling" tabindex="-1"><a class="header-anchor" href="#scaling" aria-hidden="true">#</a> Scaling</h3><p>PURISTA adapts the ideas from microservices and serverless functions to separate the logic into small pieces and to use some way of unified communication. This means you can scale things as you need.</p><p>The main difference is, that you do not need to decide at the very first step, how you like to deploy or how you like to scale at the end.<br> You can simply start local and scale when you need. You are not nailed down to start with infrastructure or architectural questions and setups.</p><p>Start small and efficient, like you would do with the beginners &quot;hello world&quot; example, and move to the solution which fits your needs.</p><p>You are not limited to scale &quot;the whole blob&quot;. You are able to scale parts of your software differently.</p><p>As an example, you might have some function which takes longer for processing data. This means this function can&#39;t handle the same amount of requests, then the rest of your system. You are able to scale this specific part by adding more instances, without the need to have more instance for all of your functions.</p><h3 id="testing" tabindex="-1"><a class="header-anchor" href="#testing" aria-hidden="true">#</a> Testing</h3>`,75),z=e("The core concept of PURISTA is helping you, when it comes to testing."),G=s("br",null,null,-1),Q=e(" Check out the handbook chapter "),Z=e("Testing");function $(ee,se){const i=o("Mermaid"),t=o("ExternalLinkIcon"),r=o("RouterLink");return l(),d("div",null,[h,n(i,{id:"mermaid-382ee16b",code:"flowchart%20RL%0A%20%20%20%20browser%5BBrowser%5D%20--%3E%7C%2Fapi%2Fv1%2Fuser%2Fsign-up%7C%20httpService(HTTPS-Service)%0A%20%20%20%20httpService--%20user%20payload%20--%3EeventBridge(Eventbridge)%0A%20%20%20%20eventBridge--%20user%20payload%20--%3EsignUp%0A%20%20%20%20subgraph%20UserService%0A%20%20%20%20%20%20%20%20signUp%0A%20%20%20%20%20%20%20%20verifyEmail(verifyEmail)%0A%20%20%20%20end%0A%20%20%20%20signUp--%20user%20id%20--%3EeventBridge%0A%20%20%20%20eventBridge%20--%20user%20id%20--%3E%20httpService%0A%20%20%20%20httpService%20--%20user%20id%20--%3E%20browser%0A%20%20%20%20eventBridge%20-.-%3E%20verifyEmail%0A%20%20%20%20signUp%20--%3E%20database%0A%20%20%20%20database%20--%20user%20id%20--%3E%20signUp%0A%20%20%20%20verifyEmail%20--%20set%20token%20--%3Edatabase%0A%20%20%20%20verifyEmail%20--%3E%20eventBridge%0A%20%20%20%20eventBridge%20--%3E%20sendMail%0A%20%20%20%20subgraph%20EmailService%0A%20%20%20%20%20%20%20%20sendMail%0A%20%20%20%20end%0A%0A%20%20%20%20eventBridge%20-.-%3E%20countEmails%0A%20%20%20%20subgraph%20Audit%0A%20%20%20%20%20%20%20%20countEmails(countEmails)%0A%20%20%20%20end%0A%20%20%20%20countEmails%20--%3E%20database%0A%20%20%20%20database%5B(Database)%5D%0A"}),m,s("p",null,[b,f,y,s("a",g,[w,n(t)]),v,s("a",k,[_,n(t)]),A,s("a",x,[T,n(t)]),q,I,S,U,E,P,Y]),R,B,s("p",null,[D,j,M,F,C,s("a",H,[N,n(t)]),L,s("a",O,[V,n(t)]),W,J,X]),K,s("p",null,[z,G,Q,n(r,{to:"/handbook/6_testing.html"},{default:p(()=>[Z]),_:1})])])}var oe=c(u,[["render",$],["__file","0_concept.html.vue"]]);export{oe as default};
