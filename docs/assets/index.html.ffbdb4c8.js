import{r as o,a as n,b as e,e as i,w as s,F as l,d as t,c as r,o as d}from"./app.78facd3f.js";import{_ as c}from"./plugin-vue_export-helper.21dcd24c.js";const u={},p=t("@purista/core / "),h=t("Exports"),m=r('<h1 id="purista" tabindex="-1"><a class="header-anchor" href="#purista" aria-hidden="true">#</a> PURISTA</h1><p>A backend framework for building message based domain services.</p><p>This framework adapts and combines a wide range of different patters from domain driven design, cqrs, microservice, eventsourcing and lambda functions.</p><p>It is build from ground up in typescript and highly focuses on schema, and auto generation of types, input-output-validation, openApi documentation (swagger).</p><h2 id="why-to-use-purista" tabindex="-1"><a class="header-anchor" href="#why-to-use-purista" aria-hidden="true">#</a> Why to use PURISTA</h2><p>PURISTA tries to avoid the need for implementing boilerplate code as much as possible and to automate and autogenerate types, definitions, documentation when ever possible.</p><p>Schema and input-output-validation are deeply integrated and they should be used whenever possible to build robust, stable systems.</p><p>PURISTA addresses developers which want to simply focus on implementation, while providing them the necessary things to use the great node/typescript tooling.</p><h3 id="features" tabindex="-1"><a class="header-anchor" href="#features" aria-hidden="true">#</a> Features</h3><ul><li>typescript based and with typescript in mind</li><li>mostly async-await (no call-back hell)</li><li>easy versioning of services &amp; api</li><li>modular &amp; extendable</li><li>runs and scales from small single instance up to cloud clusters</li><li>flexible to trace, audit and monitor</li><li>easy to test with ready to go mocks &amp; stubs</li><li>clean error handling</li><li>low learning curve</li></ul><h2 id="does-purista-fit-for-every-use-case" tabindex="-1"><a class="header-anchor" href="#does-purista-fit-for-every-use-case" aria-hidden="true">#</a> Does PURISTA fit for every use case?</h2><p>Simply answer is <strong>NO</strong>.</p><p>If your project is mainly focused on something like processing streams (e.g. video/audio) this framework does not fit for you.<br> PURISTA is message based and there are also some low performance impacts based on the strict validations, the high useage of async-await and so on.</p>',13),_=t("Core concept"),f=t("Setup a new project"),g=t("Create a service"),v=t("Setup a new service"),b=t("Add a command function"),y=t("Add a subscription"),w=t("Error handling in service"),S=t("Testing"),x=e("li",null,[t("Webserver "),e("ul",null,[e("li",null,"Setup"),e("li",null,"OpenApi"),e("li",null,"Add routes and handlers"),e("li",null,"Serve static content"),e("li",null,"Error Handling"),e("li",null,"Proxy requests")])],-1),A=t("Scale up"),k=t("Combine different Services"),T=t("Cluster");function C(I,R){const a=o("RouterLink");return d(),n(l,null,[e("p",null,[p,i(a,{to:"/api/modules.html"},{default:s(()=>[h]),_:1})]),m,e("ul",null,[e("li",null,[i(a,{to:"/api/doc/concept.html"},{default:s(()=>[_]),_:1})]),e("li",null,[i(a,{to:"/api/doc/get-started.html"},{default:s(()=>[f]),_:1})]),e("li",null,[i(a,{to:"/api/doc/create-new-service.html"},{default:s(()=>[g]),_:1}),e("ul",null,[e("li",null,[i(a,{to:"/api/doc/create-new-service.html#Setup_a_new_service"},{default:s(()=>[v]),_:1})]),e("li",null,[i(a,{to:"/api/doc/create-new-service.html#Create_a_command_function"},{default:s(()=>[b]),_:1})]),e("li",null,[i(a,{to:"/api/doc/create-new-service.html#Create_a_subscription"},{default:s(()=>[y]),_:1})])])]),e("li",null,[i(a,{to:"/api/doc/error-handling.html"},{default:s(()=>[w]),_:1})]),e("li",null,[i(a,{to:"/api/doc/testing.html"},{default:s(()=>[S]),_:1})]),x,e("li",null,[i(a,{to:"/api/doc/scale.html"},{default:s(()=>[A]),_:1}),e("ul",null,[e("li",null,[i(a,{to:"/api/doc/scale.html"},{default:s(()=>[k]),_:1})]),e("li",null,[i(a,{to:"/api/doc/scale.html"},{default:s(()=>[T]),_:1})])])])])],64)}var N=c(u,[["render",C],["__file","index.html.vue"]]);export{N as default};
