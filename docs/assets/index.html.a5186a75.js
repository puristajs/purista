import{_ as e}from"./plugin-vue_export-helper.21dcd24c.js";import{o as a,c as i,a as t}from"./app.c31a4ec8.js";const s={},n=t('<h1 id="purista" tabindex="-1"><a class="header-anchor" href="#purista" aria-hidden="true">#</a> PURISTA</h1><p>A backend framework for building message based domain services.</p><p>This framework adapts and combines a wide range of different patters from domain driven design, cqrs, microservice, event sourcing and lambda functions.</p><p>It is build from ground up in typescript and highly focuses on schema, and auto generation of types, input-output-validation, openApi documentation (swagger).</p><h2 id="why-to-use-purista" tabindex="-1"><a class="header-anchor" href="#why-to-use-purista" aria-hidden="true">#</a> Why to use PURISTA</h2><p>PURISTA tries to avoid the need for implementing boilerplate code as much as possible and to automate and autogenerate types, definitions, documentation when ever possible.</p><p>Schema and input-output-validation are deeply integrated, and they should be used whenever possible to build robust, stable systems.</p><p>PURISTA addresses developers which want to simply focus on implementation, while providing them the necessary things to use the great node/typescript tooling.</p><h3 id="features" tabindex="-1"><a class="header-anchor" href="#features" aria-hidden="true">#</a> Features</h3><ul><li>typescript based and with typescript in mind</li><li>mostly async-await (no call-back hell)</li><li>easy versioning of services &amp; api</li><li>modular &amp; extendable</li><li>runs and scales from small single instance up to cloud clusters</li><li>flexible to trace, audit and monitor</li><li>easy to test with ready to go mocks &amp; stubs</li><li>clean error handling</li><li>low learning curve</li></ul>',10),o=[n];function r(d,l){return a(),i("div",null,o)}var u=e(s,[["render",r],["__file","index.html.vue"]]);export{u as default};
